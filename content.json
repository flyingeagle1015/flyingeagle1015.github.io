[{"title":"链表常见算法","date":"2019-03-21T06:47:09.000Z","path":"2019/03/21/list_algorithms/","text":"1.引言单链表的操作算法是笔试面试中较为常见的题目。本文将着重介绍平时面试中常见的关于链表的应用题目。 2.输出单链表倒数第 K 个节点2.1 问题描述题目：输入一个单链表，输出此链表中的倒数第 K 个节点。（去除头结点，节点计数从 1 开始）。 2.2 两次遍历法2.2.1 解题思想（1）遍历单链表，遍历同时得出链表长度 N 。（2）再次从头遍历，访问至第 N - K 个节点为所求节点。 2.2.2 代码实现12345678910111213141516171819202122const ListNode* searchNodeK(const ListNode* pHead, int k)&#123; int len = 0; const ListNode *temp = pHead; while (temp) &#123; ┊ len++; ┊ temp = temp-&gt;next; &#125; if (len &lt; k) &#123; ┊ return NULL; &#125; temp = pHead; len = len - k; while (len--) &#123; temp = temp-&gt;next; &#125; return temp;&#125; 采用这种遍历方式需要两次遍历链表，时间复杂度为O(n※2)。可见这种方式最为简单,也较好理解，但是效率低下。 2.3 递归法2.3.1 解题思想（1）定义num = k（2）使用递归方式遍历至链表末尾。（3）由末尾开始返回，每返回一次 num 减 1（4）当 num 为 0 时，即可找到目标节点 2.3.2 代码实现1234567891011121314151617181920212223242526272829const ListNode* findKthTail_in(const ListNode* pHead, int k, int *num)&#123; const ListNode *temp = NULL; if (!pHead) &#123; ┊ return NULL; &#125; temp = searchNodeK_in(pHead-&gt;next, k, num); if (temp) &#123; ┊ return temp; &#125; else &#123; ┊ *num = (*num) - 1; ┊ if (*num == 0) &#123; ┊ ┊ return pHead; ┊ &#125; else &#123; ┊ ┊ return NULL; ┊ &#125; &#125;&#125;const ListNode* findKthTail(const ListNode* pHead, int k)&#123; int num = k; if (!pHead) &#123; ┊ return NULL; &#125; return searchNodeK_in(pHead, k, &amp;num);&#125; 采用这种方式只需要一次遍历链表，时间复杂度为O(n), 但链表节点数量巨大的时候占用太多栈空间。 2.4 双指针法2.4.1 解题思想（1）定义两个指针 p1 和 p2 分别指向链表头节点。（2）p1 前进 K 个节点，则 p1 与 p2 相距 K 个节点。（3）p1，p2 同时前进，每次前进 1 个节点。（4）当 p1 指向到达链表末尾，由于 p1 与 p2 相距 K 个节点，则 p2 指向目标节点。 2.4.2 代码实现123456789101112131415161718192021const ListNode* findKthTail(const ListNode* pHead, int k)&#123; int i; const ListNode *p1 = pHead; const ListNode *p2 = pHead; for (i = 0; i &lt; k &amp;&amp; p2; i++) &#123; ┊ p2 = p2-&gt;next; &#125; if (!p2) &#123; return NULL; &#125; while (p2) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; return p1;&#125; 3. 链表中存在环问题3.1 判断链表是否有环3.1.1 哈希缓存法3.1.1.1 解题思想（1）首先创建一个以节点 ID 为键的 HashSe t集合，用来存储曾经遍历过的节点。（2）从头节点开始，依次遍历单链表的每一个节点。（3）每遍历到一个新节点，就用新节点和 HashSet 集合当中存储的节点作比较，如果发现 HashSet 当中存在相同节点 ID，则说明链表有环，如果 HashSet 当中不存在相同的节点 ID，就把这个新节点 ID 存入 HashSet ，之后进入下一节点，继续重复刚才的操作。假设从链表头节点到入环点的距离是 a ，链表的环长是 r 。而每一次 HashSet 查找元素的时间复杂度是 O(1), 所以总体的时间复杂度是 1 * ( a + r ) = a + r，可以简单理解为 O(n) 。而算法的空间复杂度还是 a + r - 1，可以简单地理解成 O(n) 。 3.1.2 快慢指针法3.1.2.1 解题思想（1）定义两个指针分别为 slow，fast，并且将指针均指向链表头节点。（2）规定，slow 指针每次前进 1 个节点，fast 指针每次前进两个节点。（3）当 slow 与 fast 相等，且二者均不为空，则链表存在环。 3.1.2.2 代码实现1234567891011121314151617int isExistLoop(const ListNode* pHead)&#123; const ListNode *fastPt = pHead; const ListNode *slowPt = pHead; // fastPt在前, fastPt不为空则slowPt不可能为空 while (fastPt &amp;&amp; fastPt-&gt;next) &#123; slowPt = slowPt-&gt;next; fastPt = fastPt-&gt;next-&gt;next; if (slowPt == fastPt)&#123; return 1; &#125; &#125; return 0;&#125; 3.2 定位环入口3.2.1 解题思想123456789101112链表头l 环入口| |--------------------------- | | | | - 相遇点p | | -----------假定链表头l到环入口点相距a个节点（即移动a次到达），相遇点距环入口为b个节点，相遇点再移动c次再次到达环入口,则：2*(a+b) = a+b + n * (b + c) 即慢指针的移动数的两倍 = 快指针移动数(第一次到达相遇点 + N圈环长度)n * (b + c) = a + ba = (n - 1)(b + c) + c 可以得出a = (n - 1)圈 + c指针p1从链表头到环入口的换，同样速度的指针p2从相遇点到出发移动n-1圈后会与p1在环入口相遇。 3.2.2 代码实现1234567891011121314151617181920212223242526const ListNode* getEntryNodeOfLoop(const ListNode* pHead)&#123; const ListNode *fastPt = pHead; const ListNode *slowPt = pHead; // 取得相遇点 while (fastPt &amp;&amp; fastPt-&gt;next) &#123; slowPt = slowPt-&gt;next; fastPt = fastPt-&gt;next-&gt;next; if (slowPt == fastPt)&#123; break; &#125; &#125; // assert(fastPt); // 确定有环 slowPt = pHead; // 再次相遇 while (slowPt != fastPt) &#123; slowPt = slowPt-&gt;next; fastPt = fastPt-&gt;next; &#125; return slowPt;&#125; 3.3 计算环长度3.3.1 解题思想123456789链表头l 环入口| |--------------------------- | | | | - 相遇点p | | -----------从相遇点出发，按慢指针移动一次快指针移动两次的规则，假定满指针转一圈快指针刚好转两圈，即再次相遇。慢指针的移动次数即为环长度。 3.3.2 代码实现123456789101112131415161718192021222324252627int getLoopLength(const ListNode* pHead)&#123; int length = 0; const ListNode *fastPt = pHead; const ListNode *slowPt = pHead; // 取得相遇点 while (fastPt &amp;&amp; fastPt-&gt;next) &#123; slowPt = slowPt-&gt;next; fastPt = fastPt-&gt;next-&gt;next; if (slowPt == fastPt)&#123; break; &#125; &#125; // assert(fastPt); // 确定有环 // 再次相遇 while (slowPt != fastPt) &#123; slowPt = slowPt-&gt;next; fastPt = fastPt-&gt;next-&gt;next; length++; &#125; return length;&#125; 4. 使用链表实现大数加法4.1 问题描述两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。例如：输入：3-&gt;1-&gt;5-&gt;null5-&gt;9-&gt;2-&gt;null，输出：8-&gt;0-&gt;8-&gt;null 4.2 代码实现12345678910111213141516171819202122232425262728293031323334353637383940ListNode* numberAddAsList(const ListNode *l1, const ListNode *l2)&#123; int pos = 0; ListNode *ret = NULL; ListNode *it = NULL; const ListNode *it1 = l1; const ListNode *it2 = l2; while (it1 || it2) &#123; ┊ if (it1) &#123; ┊ ┊ pos += it1-&gt;data; ┊ ┊ it1 = it1-&gt;next; ┊ &#125; ┊ if (it2) &#123; ┊ ┊ pos += it2-&gt;data; ┊ ┊ it2 = it2-&gt;next; ┊ &#125; ┊ if (!it) &#123; ┊ ┊ it = malloc(sizeof(*it)); ┊ ┊ it-&gt;data = pos % 10; ┊ ┊ it-&gt;next = NULL; ┊ ┊ ret = it; ┊ &#125; else &#123; ┊ ┊ it-&gt;next = malloc(sizeof(*it)); ┊ ┊ it-&gt;next-&gt;data = pos % 10; ┊ ┊ it-&gt;next-&gt;next = NULL; ┊ ┊ it = it-&gt;next; ┊ &#125; ┊ pos /= 10; &#125; if (pos) &#123; ┊ it-&gt;next = malloc(sizeof(*it)); ┊ it-&gt;next-&gt;data = pos; ┊ it-&gt;next-&gt;next = NULL; &#125; return ret;&#125; 5. 有序链表合并5.1 问题描述题目：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例：输入：1-&gt;2-&gt;4,1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 5.2 通常解法5.2.1 解题思想（1）对空链表存在的情况进行处理，假如 pHead1 为空则返回 pHead2 ，pHead2 为空则返回 pHead1。（两个都为空此情况在pHead1为空已经被拦截）（2）在两个链表无空链表的情况下确定第一个结点，比较链表1和链表2的第一个结点的值，将值小的结点保存下来为合并后的第一个结点。并且把第一个结点为最小的链表向后移动一个元素。（3）继续在剩下的元素中选择小的值，连接到第一个结点后面，并不断next将值小的结点连接到第一个结点后面，直到某一个链表为空。（4）当两个链表长度不一致时，也就是比较完成后其中一个链表为空，此时需要把另外一个链表剩下的元素都连接到第一个结点的后面。 5.2.2 代码实现123456789101112131415161718192021222324252627282930313233ListNode* mergeTwoOrderedLists(ListNode *pHead1, ListNode *pHead2)&#123; ListNode *pNewHead = NULL; ListNode *pTail = NULL; if (!pHead1 || !pHead2) &#123; return (pHead1 ? pHead1 : pHead2); &#125; if (pHead2-&gt;data &lt; pHead1-&gt;data) &#123; pNewHead = pHead2; pHead2 = pHead2-&gt;next; &#125; else &#123; pNewHead = pHead1; pHead1 = pHead1-&gt;next; &#125; pTail = pNewHead; while (pHead1 &amp;&amp; pHead2) &#123; if (pHead2-&gt;data &lt; pHead1-&gt;data) &#123; pTail-&gt;next = pHead2; pHead2 = pHead2-&gt;next; &#125; else &#123; pTail-&gt;next = pHead1; pHead1 = pHead1-&gt;next; &#125; pTail = pTail-&gt;next; &#125; pTail-&gt;next = pHead1 ? pHead1 : pHead2; return pNewHead;&#125; 5.3 递归解法5.3.1 解题思想（1）对空链表存在的情况进行处理，假如 pHead1 为空则返回 pHead2 ，pHead2 为空则返回 pHead1。（2）比较两个链表第一个结点的大小，确定头结点的位置（3）头结点确定后，继续在剩下的结点中选出下一个结点去链接到第二步选出的结点后面，然后在继续重复（2 ）（3） 步，直到有链表为空。 5.3.2 代码实现1234567891011121314ListNode* mergeTwoOrderedLists(ListNode *pHead1, ListNode *pHead2)&#123; if (!pHead1 || !pHead2) &#123; return (pHead1 ? pHead1 : pHead2); &#125; if (pHead2-&gt;data &lt; pHead1-&gt;data) &#123; pHead2-&gt;next = mergeTwoOrderedLists(pHead1, pHead2-&gt;next); return pHead2; &#125; else &#123; pHead1-&gt;next = mergeTwoOrderedLists(pHead1-&gt;next, pHead2); return pHead1; &#125;&#125; 6. 删除链表中节点，要求时间复杂度为O(1)6.1 问题描述给定一个单链表中的表头和一个等待被删除的节点。请在 O(1) 时间复杂度删除该链表节点。并在删除该节点后，返回表头。示例：给定 1-&gt;2-&gt;3-&gt;4，和节点 3，返回 1-&gt;2-&gt;4。 6.2 解题思想在之前介绍的单链表删除节点中，最普通的方法就是遍历链表，复杂度为O(n)。如果我们把删除节点的下一个结点的值赋值给要删除的结点，然后删除这个结点，这相当于删除了需要删除的那个结点。因为我们很容易获取到删除节点的下一个节点，所以复杂度只需要O(1)。示例单链表：1-&gt;2-&gt;3-&gt;4-&gt;NULL若要删除节点 3 。第一步将节点3的下一个节点的值4赋值给当前节点。变成 1-&gt;2-&gt;4-&gt;4-&gt;NULL，然后将就 4 这个结点删除，就达到目的了。 1-&gt;2-&gt;4-&gt;NULL如果删除的节点的是头节点，把头结点指向 NULL。如果删除的节点的是尾节点，那只能从头遍历到头节点的上一个结点。 6.3 代码实现1234567891011121314151617181920212223242526272829void deleteNode(ListNode **pHead, ListNode *pDelNode)&#123; ListNode *pTmpNode = NULL; if (*pHead == NULL || pDelNode == NULL) &#123; return; &#125; // 删除头节点 if (*pHead == pDelNode) &#123; *pHead = pDelNode-&gt;next; free(pDelNode); return; &#125; if (pDelNode-&gt;next) &#123; pTmpNode = pDelNode-&gt;next; pDelNode-&gt;data = pTmpNode-&gt;data; pDelNode-&gt;next = pTmpNode-&gt;next; free(pTmpNode); &#125; else &#123; // 删除尾节点 pTmpNode = *pHead; while (pTmpNode-&gt;next != pDelNode) &#123; pTmpNode = pTmpNode-&gt;next; &#125; pTmpNode-&gt;next = NULL; free(pDelNode); &#125;&#125; 7. 从尾到头打印链表7.1 问题描述输入一个链表，按链表值从尾到头的顺序返回一个 ArrayList 。 7.2 解法初看题目意思就是输出的时候链表尾部的元素放在前面，链表头部的元素放在后面。这不就是 先进后出，后进先出 么。什么数据结构符合这个要求？栈！ 代码实现：1234567891011void printListFromTailToHead(ListNode* head)&#123; // stack&lt;int&gt; stk; const ListNode *tmp = head; while (tmp) &#123; // stk.push(tmp-&gt;data) tmp = tmp-&gt;next; &#125; // stk.pop&#125; 7.3 解法二第二种方法也比较容易想到，通过链表的构造，如果将末尾的节点存储之后，剩余的链表处理方式还是不变，所以可以使用递归的形式进行处理。 代码实现：123456789void printListFromTailToHead(ListNode* head)&#123; if (!head) &#123; return; &#125; printListFromTailToHead(head-&gt;next); printf(\"%d \", head-&gt;data);&#125; 8. 反转链表8.1 题目描述反转一个单链表。示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 8.2 解题思路设置三个节点pre、cur、next（1）每次查看cur节点是否为NULL，如果是，则结束循环，获得结果（2）如果cur节点不是为NULL，则先设置临时变量next为cur的下一个节点（3）让cur的下一个节点变成指向pre，而后pre移动cur，cur移动到next（4）重复（1）（2）（3） 8.3 代码实现8.3.1 迭代实现1234567891011121314ListNode* reverseList(ListNode *head)&#123; ListNode *pre = NULL, *cur = NULL, *next = NULL; cur = head; while (cur) &#123; next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; &#125; return pre;&#125; 8.3.2 递归实现123456789101112ListNode* reverseList(ListNode *head)&#123; ListNode *rhead = NULL; if (!head || !head-&gt;next) &#123; return head; &#125; rhead = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return rhead;&#125;","tags":[{"name":"c","slug":"c","permalink":"https://flyingeagle1015.github.io/tags/c/"},{"name":"list","slug":"list","permalink":"https://flyingeagle1015.github.io/tags/list/"}]},{"title":"git简易教程","date":"2019-03-19T01:25:18.000Z","path":"2019/03/19/git_usage/","text":"创建版本库12345$ mkdir learngit$ cd learngit$ git init$ ls -la. .. .git 添加文件到版本库12345678git add readme.txtgit commit -m 'wrote a readme file'#仓库当前的状态git status#文件对比git diff readme.txtgit diff HEAD -- readme.txt 版本回退12345678git loggit log --pretty=oneline#撤回上次提交git reset --hard HEAD^ #查看命令历史git reflog#撤回到指定提交git reset --hard 801f 撤销修改1234#丢弃工作区修改git checkout -- readme.txt#撤销暂存区的修改git reset HEAD readme.txt 删除文件1git rm test.txt 分支管理创建与合并分支123456查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 冲突解决12git merge devgit log --graph --pretty=oneline --abbrev-commit 分支管理在实际开发中, 我们应该按照几个基本原则进行分支管理:首先, master分支应该是非常稳定的, 仅用来发布新版本;dev分支是不稳定的, 干活都在dev分支上, 版本发布时再把dev分支合并到master上然后发布版本;每个人都在dev分支上干活, 每个人都有自己的分支, 时不时地往dev分支上合并。 合并分支时, 加上–no-ff参数就可以用普通模式合并, 合并后的历史有分支, 能看出来曾经做过合并, 而fast forward(默认)合并就看不出来曾经做过合并。 BUG分支123456789101112git stash 暂存工作区git checkout mastergit checkout -b issue-101#fix buggit commit -a -m 'fix bug 101'git checkout mastergit merge --no-ff -m 'merged bug fix 101' issue-101git checkout devgit stash list 查看暂存git stash apply 恢复暂存但需要执行git stash drop来删除暂存git stash pop 恢复并自动删除git stash apply stash@&#123;0&#125; 恢复指定的暂存 Feature分支不让预研代码搞乱主分支代码, 对预研代码做feature分支。12345git checkout -b feature-vulcangit commit -a -m 'add feature vulcan'git checkout devgit branch -d feature-vulcangit branch -D feature-vulcan 多人协作12345678git remote 查看远程库git remote -vgit push origin master 推送分支git push origin dev 只推送别人需要查看的分支git clone git@github.com:user/learngit.gitgit checkout -b dev origin/dev 远程分支devgit pull 拉取其他人的更新git branch --set-upstream-to=origin/dev dev Rebaserebase操作的特点：把分叉的提交历史“整理”成一条直线,看上去更直观,缺点是本地的分叉提交已经被修改过了。1git rebase 标签管理创建标签12345git tag v1.0 创建标签git tag v0.9 f52c633 给历史提交打标签git tag -a v0.1 -m \"version 0.1 released\" 1094adb 打标签附带说明git tag 查看标签列表git show v0.9 查看标签信息 操作标签123456git tag -d v0.1 删除标签git push origin v1.0推送标签到远程git push origin --tags 推送全部未推送的标签从远程删除标签git tag -d v0.9git push origin :refs/tags/v0.9 自定义Git12345678910111213141516171819202122232425git config --global color.ui true#别名git config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branchgit config --global alias.unstage 'reset HEAD'git config --global alias.last 'log -1'git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\"#配置文件$REPO/.git/config$HOME/.gitconfig#忽略特殊文件.gitignore参考https://github.com/github/gitignore忽略文件的原则是：忽略操作系统自动生成的文件，比如缩略图等；忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。git add -f App.class 强制添加文件到暂存区git check-ignore -v App.class 检查.gitignore","tags":[{"name":"git","slug":"git","permalink":"https://flyingeagle1015.github.io/tags/git/"}]},{"title":"Git提交规范","date":"2019-03-19T01:14:49.000Z","path":"2019/03/19/git_commit_standard/","text":"规则&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; type用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动 scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subject是 commit 目的的简短描述，不超过50个字符。以动词开头，使用第一人称现在时，比如change，而不是changed或changes第一个字母小写结尾不加句号(.)","tags":[{"name":"git","slug":"git","permalink":"https://flyingeagle1015.github.io/tags/git/"}]},{"title":"C代码不在一行多次修改一个变量","date":"2019-03-04T09:52:51.000Z","path":"2019/03/04/c-error-mutliple-modify-one-variable/","text":"不要在同一行代码对同一变量做多次修改源于对大神项目代码学习中遇到得问题，经简化复现方便说明。示例：1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct &#123; char *buf; int top;&#125;context_t;static int faaa(context_t *c , int o)&#123; c-&gt;top += o; return 6;&#125;int main()&#123; context_t c; memset(&amp;c, 0, sizeof(c)); c.top -= 32 - faaa(&amp;c, 32); printf(\"top:%d, should be 6\\n\", c.top); return EXIT_SUCCESS;&#125;[test@test tmp]$ gcc -g -o test a.c[test@test tmp]$ ./test top:-26, should be 6 代码行中c.top -= 32 - faaa(&amp;c, 32);对c.top做了两次修改：第一次为faaa中的修改第二次为自减操作 为什么会这样呢？马上为您揭晓！123456789101112131415161718192021222324252627282930(gdb) disassemble mainDump of assembler code for function main: 0x00000000004005a2 &lt;+0&gt;: push %rbp 0x00000000004005a3 &lt;+1&gt;: mov %rsp,%rbp 0x00000000004005a6 &lt;+4&gt;: push %rbx 0x00000000004005a7 &lt;+5&gt;: sub $0x18,%rsp 0x00000000004005ab &lt;+9&gt;: lea -0x20(%rbp),%rax 0x00000000004005af &lt;+13&gt;: mov $0x10,%edx 0x00000000004005b4 &lt;+18&gt;: mov $0x0,%esi 0x00000000004005b9 &lt;+23&gt;: mov %rax,%rdi 0x00000000004005bc &lt;+26&gt;: callq 0x400460 &lt;memset@plt&gt; // 对应memset(&amp;c, 0, sizeof(c)); 0x00000000004005c1 &lt;+31&gt;: mov -0x18(%rbp),%ebx // 将c-&gt;top放到寄存器ebx 0x00000000004005c4 &lt;+34&gt;: lea -0x20(%rbp),%rax // 将c地址放到寄存器rax 0x00000000004005c8 &lt;+38&gt;: mov $0x20,%esi // 将20放到寄存器esi, 作为faaa的第二个参数 0x00000000004005cd &lt;+43&gt;: mov %rax,%rdi // rdi作为faaa的第一个参数 0x00000000004005d0 &lt;+46&gt;: callq 0x40057d &lt;faaa&gt; // 调用函数faaa 0x00000000004005d5 &lt;+51&gt;: sub $0x20,%eax // faaa返回值(返回值放eax寄存器) - 32, 这里编译器做了调整a - (b - c) =&gt; a + (c - b) 0x00000000004005d8 &lt;+54&gt;: add %ebx,%eax // 加上“缓存”中的c-&gt;top 0x00000000004005da &lt;+56&gt;: mov %eax,-0x18(%rbp) 0x00000000004005dd &lt;+59&gt;: mov -0x18(%rbp),%eax 0x00000000004005e0 &lt;+62&gt;: mov %eax,%esi 0x00000000004005e2 &lt;+64&gt;: mov $0x400690,%edi 0x00000000004005e7 &lt;+69&gt;: mov $0x0,%eax 0x00000000004005ec &lt;+74&gt;: callq 0x400450 &lt;printf@plt&gt; 0x00000000004005f1 &lt;+79&gt;: mov $0x0,%eax 0x00000000004005f6 &lt;+84&gt;: add $0x18,%rsp 0x00000000004005fa &lt;+88&gt;: pop %rbx 0x00000000004005fb &lt;+89&gt;: pop %rbp 0x00000000004005fc &lt;+90&gt;: retq End of assembler dump. 重点来了, 加上的是缓存的c-&gt;top。解决方案： 将行c.top -= 32 - faaa(&amp;c, 32);拆为两行:12int n = faaa(&amp;c, 32);c.top -= (32 - n);","tags":[{"name":"c","slug":"c","permalink":"https://flyingeagle1015.github.io/tags/c/"}]},{"title":"mysql客户端内存泄漏","date":"2019-02-26T06:58:57.000Z","path":"2019/02/26/mysql_cli_memory_leak/","text":"最近在用Valgrind检查一个库代码, 发现MYSQL的泄漏. 简化MySQL操作代码并测试得到了同样的泄漏.码：1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;mysql/mysql.h&gt;int main()&#123; MYSQL *MYSQLIns; MYSQLIns = mysql_init(NULL); mysql_real_connect(MYSQLIns, \"localhost\", \"test\", \"123456\", \"test\", 0, NULL, 0); mysql_close(MYSQLIns); return EXIT_SUCCESS;&#125; 编译： gcc -g -L/usr/lib64/mysql -lmysqlclient mysql_mem_test.c -o mysql_mem_test Valgrind输出：1234567891011121314151617181920212223242526272829303132333435363738394041valgrind --leak-check=full ./mysql_mem_test==26126== Memcheck, a memory error detector==26126== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.==26126== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info==26126== Command: ./mysql_mem_test==26126== ==26126== ==26126== HEAP SUMMARY:==26126== in use at exit: 8,408 bytes in 4 blocks==26126== total heap usage: 77 allocs, 73 frees, 68,596 bytes allocated==26126== ==26126== 56 bytes in 1 blocks are possibly lost in loss record 1 of 4==26126== at 0x4C29E83: malloc (vg_replace_malloc.c:299)==26126== by 0x4E999E7: my_raw_malloc (my_malloc.c:191)==26126== by 0x4E999E7: my_malloc (my_malloc.c:54)==26126== by 0x4E98A1C: my_error_register (my_error.c:310)==26126== by 0x4E5CC24: mysql_server_init (libmysql.c:116)==26126== by 0x4E655B6: mysql_init (client.c:2460)==26126== by 0x4006CE: main (a.c:9)==26126== ==26126== 176 bytes in 1 blocks are possibly lost in loss record 2 of 4==26126== at 0x4C29E83: malloc (vg_replace_malloc.c:299)==26126== by 0x4E999E7: my_raw_malloc (my_malloc.c:191)==26126== by 0x4E999E7: my_malloc (my_malloc.c:54)==26126== by 0x4E97B8A: init_alloc_root (my_alloc.c:77)==26126== by 0x4E6F01B: mysql_client_plugin_init (client_plugin.c:342)==26126== by 0x4E5CC2B: mysql_server_init (libmysql.c:117)==26126== by 0x4E655B6: mysql_init (client.c:2460)==26126== by 0x4006CE: main (a.c:9)==26126== ==26126== LEAK SUMMARY:==26126== definitely lost: 0 bytes in 0 blocks==26126== indirectly lost: 0 bytes in 0 blocks==26126== possibly lost: 232 bytes in 2 blocks==26126== still reachable: 8,176 bytes in 2 blocks==26126== suppressed: 0 bytes in 0 blocks==26126== Reachable blocks (those to which a pointer was found) are not shown.==26126== To see them, rerun with: --leak-check=full --show-leak-kinds=all==26126== ==26126== For counts of detected and suppressed errors, rerun with: -v==26126== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0) 查阅MySQL C API了解到:在非多线程环境中， mysql_init()根据需要自动调用mysql_library_init()。但是mysql_library_init()不是线程安全的，因此在多线程环境应该在mysql_init()且产生任何线程之前调用mysql_library_init()，或者使用互斥锁来保护mysql_library_init()。这应该在任何其他客户端库调用之前完成。mysql_close()仅释放mysql_init()或mysql_connect()创建的连接，而不会释放mysql_library_init()分配的内存，需要调用mysql_library_end()执行一些内存清理.","tags":[{"name":"c","slug":"c","permalink":"https://flyingeagle1015.github.io/tags/c/"},{"name":"mysql","slug":"mysql","permalink":"https://flyingeagle1015.github.io/tags/mysql/"}]},{"title":"ssh broken pipe","date":"2019-02-13T07:38:44.000Z","path":"2019/02/13/ssh-brokenpipe/","text":"ProblemI use Manjaro Linux at my workplace in a virtual machine hosted by VMWare Workstation. Today I am experiencing issues when I try to connect to servers via ssh.Every time I try to connect, SSH fails with12$ ssh -T git@github.compacket_write_wait: Connection to xxx port 22: Broken pipe Solutionadded “IPQoS throughput” to my ssh_config and now I can connect to all hosts again!1echo \"IPQoS throughput\" | sudo tee -a /etc/ssh/ssh_config // -a 是追加的意思，等同于 &gt;&gt;","tags":[{"name":"ssh","slug":"ssh","permalink":"https://flyingeagle1015.github.io/tags/ssh/"}]},{"title":"python deepcopy","date":"2019-02-13T06:57:04.000Z","path":"2019/02/13/python-deepcopy/","text":"先说结论 对于简单的object用shallow copy和deep copy没有区别:1234567891011121314151617&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1, 2, 3, 4]&gt;&gt;&gt; b = copy.copy(a)&gt;&gt;&gt; c = copy.deepcopy(a)&gt;&gt;&gt; id(a)139626388915464&gt;&gt;&gt; id(b)139626389057352&gt;&gt;&gt; id(c)139626389086280&gt;&gt;&gt; a[1] = 11&gt;&gt;&gt; a[1, 11, 3, 4]&gt;&gt;&gt; b[1, 2, 3, 4]&gt;&gt;&gt; c[1, 2, 3, 4] 对于复杂的object如list中套着list的情况, shallow copy时子list并未从原object真的独立出来12345678910111213141516171819202122232425262728&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1, 2, 3, 4, [11, 22, 33]]&gt;&gt;&gt; id(a[4])139626388917384&gt;&gt;&gt; id(a)139626389086408&gt;&gt;&gt; &gt;&gt;&gt; b = copy.copy(a)&gt;&gt;&gt; c = copy.deepcopy(a)&gt;&gt;&gt; &gt;&gt;&gt; id(b)139626388915464&gt;&gt;&gt; id(b[4])139626388917384 # b[4]和a[4]引用同一个对象&gt;&gt;&gt; id(c)139626389057352&gt;&gt;&gt; id(c[4])139626389086472&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; a[4][0]=111&gt;&gt;&gt; a[1, 2, 3, 4, [111, 22, 33]]&gt;&gt;&gt; b[1, 2, 3, 4, [111, 22, 33]]&gt;&gt;&gt; c[1, 2, 3, 4, [11, 22, 33]]&gt;&gt;&gt;","tags":[{"name":"python","slug":"python","permalink":"https://flyingeagle1015.github.io/tags/python/"}]},{"title":"ssh远程服务器文件修改","date":"2017-08-12T14:11:25.000Z","path":"2017/08/12/ssh_remotefile/","text":"在工作中时常需要修改远程服务器上的文件，直接用ssh登录远程服务器进行修改是最简单直接的,但比如要临时修改服务器上的代码（不提倡这么做，这里只是举例）做调试之类的，需要语法高亮难道还在服务器上配置一番???在本地配置好的环境进行修改当然是最方便的了，那如何在本地修改远程服务器上的代码呢？常用的有这几个： 如果服务器有配置Samba, 采用磁盘映射的方式 如果文件少，直接用vim远程编辑, 命令：vim scp://hostname//path/to/file 本地安装sshfs, 用sshfs映射到本地进行编辑挂载: sshfs username@serverip:serverpath localpath // 如果配置ssh key可以实现自动化挂载卸载: fusermount -u mountpath 本地修改，采用rsync同步到远程服务器","tags":[{"name":"ssh","slug":"ssh","permalink":"https://flyingeagle1015.github.io/tags/ssh/"}]},{"title":"pacman的使用","date":"2017-06-27T06:00:45.000Z","path":"2017/06/27/pacman_usage/","text":"Pacman 是一个命令行工具，这意味着当你执行下面的命令时，必须在终端或控制台中进行。 1、更新系统在 Arch Linux 系列系统中，使用一条命令即可对整个系统进行更新：1pacman -Syu 如果你已经使用 pacman -Sy 将本地的包数据库与远程的仓库进行了同步，也可以只执行：1pacman -Su 2、安装包1234pacman -S 包名 例如，执行 pacman -S firefox 将安装 Firefox。你也可以同时安装多个包，只需以空格分隔包名即可。pacman -Sy 包名 与上面命令不同的是，该命令将在同步包数据库后再执行安装。pacman -Sv 包名 在显示一些操作信息后执行安装。pacman -U 安装本地包，其扩展名为 pkg.tar.gz。 3、删除包123pacman -R 包名 该命令将只删除包，不包含该包的依赖。pacman -Rs 包名 在删除包的同时，也将删除其依赖。pacman -Rd 包名 在删除包时不检查依赖。 4、搜索包123pacman -Ss 关键字 这将搜索含关键字的包。pacman -Qi 包名 查看有关包的信息。pacman -Ql 包名 列出该包的文件。 5、其他用法 pacman -Sw 包名 只下载包，不安装。 pacman -Sc Pacman 下载的包文件位于 /var/cache/pacman/pkg/ 目录。该命令将清理未安装的包文件。 pacman -Scc 清理所有的缓存文件。","tags":[{"name":"blog","slug":"blog","permalink":"https://flyingeagle1015.github.io/tags/blog/"}]},{"title":"ThinkPHP3.2.3动态包含文件解决方案","date":"2017-06-23T03:36:46.000Z","path":"2017/06/23/thinkphp3-2-3-dynamically-include-templatefile/","text":"老手莫喷哦，我是PHP小菜！使用场景：用户选择需要的页面，动态生成选项卡TAB页。预想代码实现如下：123456789&lt;!-- 其他模板代码 --&gt;&lt;div class=\"tabbable\"&gt; &lt;!-- nav-tabs 相关代码 --&gt; &lt;div class=\"tab-content\"&gt; &lt;foreach name=\"tabfiles\" item=\"ff\"&gt; &lt;include file=\"$ff\" /&gt; &lt;!-- ThinkPHP不支持，这里无法加载文件 --&gt; &lt;/foreach&gt; &lt;/div&gt;&lt;/div&gt; 然而ThinkPHP3.2.3的include标签不支持动态解析。首先想到的是纯php实现文件内容读取，实现代码如下：123456789&lt;!-- 其他模板代码 --&gt;&lt;div class=\"tabbable\"&gt; &lt;!-- nav-tabs 相关代码 --&gt; &lt;div class=\"tab-content\"&gt; &lt;foreach name=\"tabfiles_content\" item=\"ff\"&gt; &lt;!-- tabfiles_content是文件内容的数组 --&gt; $ff &lt;!-- 直接输出文件内容 --&gt; &lt;/foreach&gt; &lt;/div&gt;&lt;/div&gt; 另一种方法类似，只是把文件读取放在模板中，代码如下：123456789&lt;!-- 其他模板代码 --&gt;&lt;div class=\"tabbable\"&gt; &lt;!-- nav-tabs 相关代码 --&gt; &lt;div class=\"tab-content\"&gt; &lt;foreach name=\"tabfiles\" item=\"ff\"&gt; &lt;?php include_once($ff); ?&gt; &lt;!-- PHP 读取文件内容 --&gt; &lt;/foreach&gt; &lt;/div&gt;&lt;/div&gt; 忍不住激动的心情，在浏览器里刷一下，页面真的出来了耶，然而细看一下发现PHP相关变量没有解析，显示也有问题~~~经过查阅ThinkPHP的模板解析代码ThinkPHP/Library/Think/Template.class.php代码，终于感到了上天发现了它的秘密，果断修改显示模板的实现：12//$this-&gt;display('mytabpage');修改为$this-&gt;show($this-&gt;fetch('mytabpage')); 哇哦，漂亮的页面终于出来了！！！","tags":[{"name":"php","slug":"php","permalink":"https://flyingeagle1015.github.io/tags/php/"},{"name":"thinkphp","slug":"thinkphp","permalink":"https://flyingeagle1015.github.io/tags/thinkphp/"}]},{"title":"markdown语法","date":"2017-03-30T06:19:15.000Z","path":"2017/03/30/markdown-syntax/","text":"Markdown Syntax ReferenceFrom http://daringfireball.net/projects/markdown/ Markdown is a text-to-HTML conversion tool for web writers. Markdown allowsyou to write using an easy-to-read, easy-to-write plain text format, thenconvert it to structurally valid XHTML (or HTML). Dataset summaries and discussions on data.world use the Markdown format. Thismeans that users can create beautiful documentation with simple markup that’seasy to write and read. This document will show you how to take advantage of Markdown to format yoursummary and discussion posts. Phrase Emphasis12*italic* **bold**_italic_ __bold__ italic bold LinksInline:1An [example](http://url.com/ \"Title\") An example Reference style labels (titles are optional): 1234An [example][id]. Then, anywhereelse in the doc, define the link: [id]: http://example.com/ \"Title\" ImagesInline (title is optional):1![alt text](/path/img.jpg \"Title\") Reference style:123![alt text][id] [id]: /url/to/img.jpg \"Title\" HeadersThe following formats can all be used interchangeably for headers.12345678910111213Header 1========Header 2--------# Header 1 ### Header 2 ### Header 1## Header 2 ListsOrdered, without paragraphs:121. Foo2. Bar Foo Bar Unordered, with paragraphs:123* A list item. With multiple paragraphs.* Bar A list item.With multiple paragraphs. Bar You can nest them:12345678* An unordered list item * A nested unordered list item* Another list item 1. The first nested ordered list item 2. A second nested ordered list item * A nested unordered list 3. This is the last nested ordered list item* The last unordered list item An unordered list item A nested unordered list item Another list item The first nested ordered list item A second nested ordered list item A nested unordered list This is the last nested ordered list item The last unordered list item Blockquotes123456&gt; Email-style angle brackets&gt; are used for blockquotes.&gt; &gt; And, they can be nested.&gt; &gt;&gt; * You can quote a list.&gt; * Etc. Email-style angle bracketsare used for blockquotes. And, they can be nested. You can quote a list. Etc. Code Spans12`&lt;code&gt;` spans are delimitedby backticks. 12You can include literal backtickslike `` `this` ``. Pre-formatted Code BlocksIndent every line of a code block by at least 4 spaces or 1 tab, and use acolon at the end of the preceding paragraph. 1234This is a normal paragraph: This is a preformatted code block. 1234Preceded by a space, the colon disappears. : This is a preformatted code block. Wrapping code in three back-ticks will also format code blocks : 1Code goes here Horizontal RulesThree or more dashes or asterisks:123---* * *- - - - Manual Line BreaksEnd a line with two or more spaces:12Roses are red,••Violets are blue. (where • is a space) Video/Prezi Embeds(data.world dataset summaries only) Youtube123456789@[youtube](dQw4w9WgXcQ)@[youtube](http://www.youtube.com/embed/dQw4w9WgXcQ)@[youtube](https://www.youtube.com/watch?v=dQw4w9WgXcQ&amp;feature=feedrec_centerforopenscience_index)@[youtube](http://www.youtube.com/user/IngridMichaelsonVEVO#p/a/u/1/QdK8U-VIH_o)@[youtube](http://www.youtube.com/v/dQw4w9WgXcQ?fs=1&amp;amp;hl=en_US&amp;amp;rel=0)@[youtube](http://www.youtube.com/watch?v=dQw4w9WgXcQ#t=0m10s)@[youtube](http://www.youtube.com/embed/dQw4w9WgXcQ?rel=0)@[youtube](http://www.youtube.com/watch?v=dQw4w9WgXcQ)@[youtube](http://youtu.be/dQw4w9WgXcQ) Vimeo123@[vimeo](19706846)@[vimeo](https://vimeo.com/19706846)@[vimeo](https://player.vimeo.com/video/19706846) Prezi1234@[prezi](1kkxdtlp4241)@[prezi](https://prezi.com/1kkxdtlp4241/valentines-day/)@[prezi](https://prezi.com/e3g83t83nw03/destination-prezi-template/)@[prezi](https://prezi.com/prg6t46qgzik/anatomy-of-a-social-powered-customer-service-win/) Math Formulas (MathJax)(data.world dataset summaries only) 123When $a \\ne 0$, there are two solutions to \\\\(ax^2 + bx + c = 0\\\\) and they are$$x = &#123;-b \\pm \\sqrt&#123;b^2-4ac&#125; \\over 2a&#125;.$$ See MathJax Homepage for more information.","tags":[{"name":"markdown","slug":"markdown","permalink":"https://flyingeagle1015.github.io/tags/markdown/"}]}]